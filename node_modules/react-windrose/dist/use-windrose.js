import { max } from "d3-array";
import { scaleBand, scaleLinear, scaleOrdinal } from "d3-scale";
import { arc, stack } from "d3-shape";
import { useMemo } from "react";
import { radians, sumRow, TURN } from "./util.js";
const directionAccessor = (d) => d.direction;
function getMaxY(data, bins) {
    const dataWithTotals = data.map((row) => ({
        ...row,
        total: sumRow(row, bins),
    }));
    return max(dataWithTotals, (d) => d.total);
}
/**
 * A React hook that generates the necessary scales and data transformations for a wind rose chart.
 * This hook handles the creation of angular scales for directions, radial scales for values,
 * color scales for bins, and arc generators for the segments.
 *
 * @template TBins - Type of the bins array
 * @template TDirections - Type of the directions array
 * @param props - Configuration object for the wind rose chart
 * @returns An object containing:
 *   - directionScale: Scale for positioning direction labels
 *   - yScale: Radial scale for mapping values to radius
 *   - colorScale: Ordinal scale for mapping bins to colors
 *   - arcGenerator: Function for generating arc paths for segments
 *   - stackedData: Data transformed for stacked segments
 *   - angleStep: Angular step between segments
 *   - angleOffset: Angular offset for centering segments
 */
export function useWindRose({ data, bins, innerRadius, outerRadius, colorScheme, labelDirections, padAngle = 0.05, maxY = getMaxY(data, bins) ?? 1, }) {
    const dataDirections = useMemo(() => data.map(directionAccessor), [data]);
    // An angular scale for directions of the bins
    const arcDirectionScale = useMemo(() => scaleBand()
        .domain(dataDirections)
        .range([0, radians(TURN)])
        .align(0), [dataDirections]);
    // We might have fewer labels than directions, so we a separate scale for the labels
    const directionScale = useMemo(() => scaleBand()
        .domain(labelDirections ?? dataDirections)
        .range([0, radians(TURN)])
        .align(0), [labelDirections, dataDirections]);
    const yScale = useMemo(() => {
        return scaleLinear().domain([0, maxY]).range([innerRadius, outerRadius]);
    }, [innerRadius, outerRadius, maxY]);
    const colorScale = useMemo(() => scaleOrdinal().domain(bins).range(colorScheme), [bins, colorScheme]);
    const arcGenerator = useMemo(() => arc()
        .startAngle((d) => arcDirectionScale(d.data.direction))
        .endAngle((d) => arcDirectionScale(d.data.direction) +
        arcDirectionScale.bandwidth())
        .innerRadius((d) => yScale(d[0]))
        .outerRadius((d) => yScale(d[1]))
        .padRadius(innerRadius)
        .padAngle(padAngle), [innerRadius, padAngle, arcDirectionScale, yScale]);
    const stackedData = useMemo(() => stack().keys(bins)(data), [data, bins]);
    const angleStep = TURN / (labelDirections ?? dataDirections).length;
    const angleOffset = -angleStep / 2;
    return {
        directionScale,
        directions: labelDirections ?? dataDirections,
        yScale,
        colorScale,
        arcGenerator,
        stackedData,
        angleStep,
        angleOffset,
    };
}
//# sourceMappingURL=use-windrose.js.map