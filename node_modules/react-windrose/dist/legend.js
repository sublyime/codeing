import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 * Renders a vertical legend for a windrose chart
 * @param props - The component props
 * @returns An SVG group element containing the legend
 */
export function VerticalLegend({ bins, colorScheme, symbolWidth = 18, symbolHeight = symbolWidth, spacing = 2, textX = symbolWidth + 4, textY = symbolWidth / 2, symbol = "rect", symbolProps, textProps, children, ...props }) {
    if (colorScheme.length < bins.length) {
        throw new Error("Color scheme must at least as long as bins");
    }
    const legendColorScheme = colorScheme.slice(0, bins.length).toReversed();
    const totalSpacing = symbolHeight + spacing;
    return (_jsxs("g", { name: "legend", ...props, children: [children, [...bins].toReversed().map((legendEntry, index) => {
                return (_jsxs("g", { transform: `translate(0,${index * totalSpacing})`, children: [symbol === "rect" ? (_jsx("rect", { fill: legendColorScheme[index], width: symbolWidth, height: symbolHeight, stroke: "black", ...symbolProps })) : (_jsx("circle", { fill: legendColorScheme[index], r: symbolWidth / 2, cx: symbolWidth / 2, cy: symbolHeight / 2, stroke: "black", ...symbolProps })), _jsx("text", { x: textX, y: textY, dominantBaseline: "middle", fontSize: 13, ...textProps, children: legendEntry })] }, legendEntry));
            })] }));
}
/**
 * Renders a horizontal legend for a windrose chart
 * @param props - The component props
 * @returns An SVG group element containing the legend
 */
export function HorizontalLegend({ bins, colorScheme, symbolWidth = 20, symbolHeight = symbolWidth, spacing = 2, textX = symbolWidth / 2, textY = 1.5 * symbolHeight, symbol = "rect", symbolProps, textProps, children, ...props }) {
    if (colorScheme.length < bins.length) {
        throw new Error("Color scheme must at least as long as bins");
    }
    const legendColorScheme = colorScheme.slice(0, bins.length);
    const totalSpacing = symbolWidth + spacing;
    return (_jsxs("g", { name: "legend", ...props, children: [children, [...bins].map((legendEntry, index) => {
                return (_jsxs("g", { transform: `translate(${totalSpacing * index},0)`, children: [symbol === "rect" ? (_jsx("rect", { fill: legendColorScheme[index], width: symbolWidth, height: symbolHeight, stroke: "black", ...symbolProps })) : (_jsx("circle", { fill: legendColorScheme[index], r: symbolWidth / 2, cx: symbolWidth / 2, cy: symbolHeight / 2, stroke: "black", ...symbolProps })), _jsx("text", { x: textX, y: textY, fontSize: 11, textAnchor: "middle", ...textProps, children: legendEntry })] }, legendEntry));
            })] }));
}
//# sourceMappingURL=legend.js.map